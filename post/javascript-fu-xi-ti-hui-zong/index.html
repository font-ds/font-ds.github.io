<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>JavaScript 复习题汇总 | font-ds</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://font-ds.github.io/favicon.ico?v=1648017162611">
<link rel="stylesheet" href="https://font-ds.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="1. 数据类型
js中有8种数据类型
基础类型：number	string	boolen	null	undifiend    symbol
引用类型：object	function
js几种类型的值

栈：原始数据类型（Undefined，..." />
    <meta name="keywords" content="JavaScript" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://font-ds.github.io">
        <img src="https://font-ds.github.io/images/avatar.png?v=1648017162611" class="site-logo">
        <h1 class="site-title">font-ds</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      温故而知新
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://font-ds.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">JavaScript 复习题汇总</h2>
            <div class="post-date">2022-03-23</div>
            
              <div class="feature-container" style="background-image: url('https://font-ds.github.io/post-images/javascript-fu-xi-ti-hui-zong.jpeg')">
              </div>
            
            <div class="post-content" v-pre>
              <h1 id="1-数据类型">1. 数据类型</h1>
<p>js中有8种数据类型</p>
<p>基础类型：number	string	boolen	null	undifiend    symbol</p>
<p>引用类型：object	function</p>
<p><strong>js几种类型的值</strong></p>
<ul>
<li>栈：原始数据类型（<code>Undefined</code>，<code>Null</code>，<code>Boolean</code>，<code>Number</code>、<code>String</code>）</li>
<li>堆：引用数据类型（对象、数组和函数）</li>
<li>两种类型的区别是：存储位置不同；</li>
<li>原始数据类型直接存储在栈(<code>stack</code>)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；</li>
<li>引用数据类型存储在堆(<code>heap</code>)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其</li>
<li>在栈中的地址，取得地址后从堆中获得实体</li>
</ul>
<h1 id="2-对象深浅克隆头条">2. 对象深浅克隆（头条）</h1>
<p><strong>浅克隆</strong>：只是把对象第一层克隆下来</p>
<ul>
<li>
<pre><code class="language-js">let obj = {
    a : 100,
    b : [10,10,10,10],
    c : {
        x : 10
    },
    d : /^\d+$/
}

// 下边两种方式都是浅克隆

// 方式一
 let obj2 = {
     ...obj
 }
 
// 方式二
let obj2 = {}
for(let key in obj){
    if(!obj.hasOwnProperty(key)) break;
    obj2[key] = obj[key]
}
</code></pre>
</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://uploadbeta.com/share-image/ibz" alt="浅拷贝" loading="lazy"></figure>
<p><strong>深克隆</strong></p>
<ul>
<li>
<pre><code class="language-js">let obj = {
    a : 100,


    b : [10,10,10,10],
    c : {
        x : 10
    },
    d : /^\d+$/
}


// 下列方式实现深克隆

// 方式一  双JSON转换
let obj2 = JSON.stringify(obj)    // JSOn.stringify 会忽略正则，函数，Symbol，undefined
obj2 = JSOn.parse(obj2)

// 方式二  递归多层浅克隆实现深克隆
function deepClone(obj){
    // 过滤特殊情况
    if(obj === null) return null
    if(typeof obj === 'function') return new Function(obj)
    if(typeof obj !== 'object') return obj
    // 判断正则
    if(obj instanceof RegExp) return new RegExp(obj)
    // 判断date
    if(obj instanceof Date) return new Date(obj)
    
    
    // 不直接创建空对象，目的：克隆的结果和之前保持相同的所属类
    let newObj = new obj.constructor
    for(let key in obj){
        if(obj.hasOwnProperty(key)){
            newObj[key] = deepClone(obj[key])
        }
    }
    
    return newObj
}
</code></pre>
</li>
</ul>
<h1 id="3-堆栈">3. 堆栈</h1>
<p>堆：存储引用类型值的空间</p>
<p>栈：存储基本类型值和执行代码的环境</p>
<h1 id="4-localstorage-sessionstorage">4. localStorage &amp; sessionStorage</h1>
<p>localStorage 和 sessionStorage 属性允许在浏览器中存储 key/value 对的数据。</p>
<p>sessionStorage 用于临时保存同一窗口(或标签页)的数据，在关闭窗口或标签页之后将会删除这些数据。</p>
<p>在浏览器窗口关闭后还保留数据，可以使用 <a href="https://www.runoob.com/jsref/prop-win-localstorage.html">localStorage</a> 属性。</p>
<h1 id="5-请描述一下-cookiessessionstorage-和-localstorage-的区别">5. 请描述一下 <code>cookies</code>，<code>sessionStorage</code> 和 <code>localStorage</code> 的区别</h1>
<ul>
<li><code>cookie</code>是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）</li>
<li><code>cookie</code>数据始终在同源的http请求中携带（即使不需要），即会在浏览器和服务器间来回传递</li>
<li><code>sessionStorage</code>和<code>localStorage</code>不会自动把数据发给服务器，仅在本地保存</li>
<li>存储大小：
<ul>
<li><code>cookie</code>数据大小不能超过4k</li>
<li><code>sessionStorage</code>和<code>localStorage</code>虽然也有存储大小的限制，但比<code>cookie</code>大得多，可以达到5M或更大</li>
</ul>
</li>
<li>有期时间：
<ul>
<li><code>localStorage</code> 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据</li>
<li><code>sessionStorage</code> 数据在当前浏览器窗口关闭后自动删除</li>
<li><code>cookie</code> 设置的<code>cookie</code>过期时间之前一直有效，即使窗口或浏览器关闭</li>
</ul>
</li>
</ul>
<h1 id="6-web开发中会话跟踪的方法有哪些">6. web开发中会话跟踪的方法有哪些</h1>
<ul>
<li><code>cookie</code></li>
<li><code>session</code></li>
<li><code>url</code>重写</li>
<li>隐藏<code>input</code></li>
<li><code>ip</code>地址</li>
</ul>
<h1 id="7-请你谈谈cookie的弊端">7. 请你谈谈Cookie的弊端</h1>
<blockquote>
<p><code>cookie</code>虽然在持久保存客户端数据提供了方便，分担了服务器存储的负担，但还是有很多局限性的</p>
</blockquote>
<ul>
<li>每个特定的域名下最多生成<code>20</code>个<code>cookie</code></li>
<li><code>IE6</code>或更低版本最多<code>20</code>个<code>cookie</code></li>
<li><code>IE7</code>和之后的版本最后可以有<code>50</code>个<code>cookie</code></li>
<li><code>Firefox</code>最多50个<code>cookie</code></li>
<li><code>chrome</code>和<code>Safari</code>没有做硬性限制</li>
<li>IE 和 Opera 会清理近期最少使用的 <code>cookie</code>，<code>Firefox</code> 会随机清理 <code>cookie</code></li>
<li><code>cookie</code> 的最大大约为 <code>4096</code> 字节，为了兼容性，一般设置不超过 <code>4095</code> 字节</li>
<li>如果 <code>cookie</code> 被人拦截了，就可以取得所有的 <code>session</code> 信息</li>
</ul>
<h1 id="8-闭包">8. 闭包</h1>
<ul>
<li>闭包就是能够读取其他函数内部变量的函数</li>
<li>闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量，利用闭包可以突破作用链域</li>
<li>闭包的特性：
<ul>
<li>函数内再嵌套函数</li>
<li>内部函数可以引用外层的参数和变量</li>
<li>参数和变量不会被垃圾回收机制回收</li>
</ul>
</li>
</ul>
<p><strong>说说你对闭包的理解</strong></p>
<ul>
<li>使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念</li>
<li>闭包 的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中</li>
<li>闭包的另一个用处，是封装对象的私有属性和私有方法</li>
<li><strong>好处</strong>：能够实现封装和缓存等；</li>
<li><strong>坏处</strong>：就是消耗内存、不正当使用会造成内存溢出的问题</li>
</ul>
<p><strong>使用闭包的注意点</strong></p>
<ul>
<li>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露</li>
<li>解决方法是，在退出函数之前，将不使用的局部变量全部删除</li>
</ul>
<h1 id="9-说说对作用域链的理解">9. 说说对作用域链的理解</h1>
<ul>
<li>作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到<code>window</code>对象即被终止，作用域链向下访问变量是不被允许的</li>
<li>简单的说，作用域就是变量和函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期</li>
</ul>
<h1 id="10-js原型原型链-有什么特点">10. JS原型，原型链 ？有什么特点 ？</h1>
<ul>
<li>每个对象都会在其内部初始化一个属性，就是<code>__proto__</code></li>
<li>当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么就会去 <code>__proto__</code> 里找个属性，这个<code>__proto__</code>又有自己的<code>__proto__</code>，于是就这样一直找下去，也就是我们平时所说的原型链的概念。按照标准，<code>__proto__</code>是不对外公开的，也就是私有属性</li>
<li>关系：<code>instance.constructor.prototye == instance.__proto__</code></li>
</ul>
<pre><code class="language-js">let a = {}
a.consutructor.prototpe == a.__proto__
</code></pre>
<ul>
<li>
<p>特点：</p>
<ul>
<li><code>JavaScript</code> 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变</li>
<li>当我们需要一个属性时，<code>JavaScript</code> 引擎会先看当前对象中是否有这个属性，如果没有就会查找他的 <code>Prototype</code> 对象是否有这个属性，如此递推下去，一直检索到 <code>Object</code> 内建对象</li>
</ul>
</li>
<li>
<p><strong>原型</strong></p>
<ul>
<li><code>JavaScript</code> 的所有对象中都包含了一个 <code>[__proto__]</code> 内部属性，这个属性所对应的就是该对象的原型</li>
<li><code>JavaScript</code> 的函数对象，除了原型 <code>[__proto__]</code> 之外，还预置了 <code>prototype</code> 属性</li>
<li>当函数对象作为构造函数创造实例时，该 <code>prototype</code> 属性值将被作为实例对象的原型 <code>[__proto__]</code></li>
</ul>
</li>
<li>
<p><strong>原型链</strong></p>
<ul>
<li>当一个对象调用的属性/方法自身不存在时，就会去自己 <code>[__proto__]</code> 关联的前辈 <code>prototype</code> 对象上去找</li>
<li>如果没找到，就会去该 <code>prototype</code> 原型 <code>[__proto__]</code> 关联的前辈 <code>prototype</code> 去找。依此类推，直到找到属性/方法或 <code>undefined</code> 为止，从而形成了所谓的<strong>原型链</strong></li>
</ul>
</li>
<li>
<p><strong>原型特点</strong></p>
<ul>
<li><code>JavsScript</code> 对象是通过引用来传递的，当修改原型时，与之相关的对象也会继承这一改变</li>
</ul>
</li>
</ul>
<h1 id="11-解释事件代理">11. 解释事件代理</h1>
<ul>
<li>事件代理（<code>Event Delegation</code>），又称之为事件委托。是 <code>JavaScript</code> 中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担任事件监听的职责。事件代理的原理是DOM元素的事件冒泡。使用事件代理的好处是可以提高性能</li>
<li>可以大量节省内存占用，减少事件注册。比如在 <code>table</code> 上代理所有 <code>td</code> 的 <code>click</code> 事件就非常棒</li>
<li>可以实现当新增子对象时无需再次对其绑定</li>
</ul>
<pre><code class="language-html"> 	&lt;ul id=&quot;ul1&quot;&gt;
        &lt;li id=&quot;item1&quot;&gt;item1&lt;/li&gt;
        &lt;li id=&quot;item2&quot;&gt;item2&lt;/li&gt;
        &lt;li  id=&quot;item3&quot;&gt;item3&lt;/li&gt;
    &lt;/ul&gt;
    &lt;script&gt;
        window.onload= function () {
        var ul=document.getElementById(&quot;ul1&quot;);

        ul.onclick= function (event) {
            var e=event||window.event;
            var event= e.target || e.srcElement;     // e.srcElement 时IE里的属性
            switch (event.id){
                case &quot;item1&quot;:
                    alert(&quot;item1&quot;);
                    break;
                case &quot;item2&quot;:
                    alert(&quot;item2&quot;);
                    break;
                case &quot;item3&quot;:
                    alert(&quot;item3&quot;);
                    break;
            }
        }
    }
    &lt;/script&gt;
</code></pre>
<h1 id="12-javascript-实现继承">12. JavaScript 实现继承</h1>
<ul>
<li>构造继承</li>
<li>原型继承</li>
<li>实例继承</li>
<li>拷贝继承</li>
<li>原型 <code>prototype</code> 机制或 <code>apply</code> 和 <code>call</code> 方法去实现较简单，建议使用构造函数与原型混合方式</li>
</ul>
<pre><code class="language-js">function Parent(){
    this.name = 'wang'
}

function Child(){
    this.age = 28
}

Child.prototype = new Parent()  // 继承了Parent，通过原型

let demo = new Child()
console.log(demo.age,demo.name)
</code></pre>
<p><a href="https://www.jb51.net/article/81766.htm">JavaScript是如何实现继承的(六种方式)_javascript技巧_脚本之家 (jb51.net)</a></p>
<h1 id="13-this对象的理解">13. this对象的理解</h1>
<ul>
<li><code>this</code> 总是指向函数的直接调用者（而非间接调用者）</li>
<li>如果有 <code>new</code> 关键字，<code>this</code> 指向 <code>new</code> 出来的那个对象</li>
<li>在事件中，<code>this</code> 指向触发这个事件的对象</li>
</ul>
<p><strong>this指向</strong></p>
<ul>
<li>
<p><code>this</code> 的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定 <code>this</code> 到底指向谁，实际上 <code>this</code> 的最终指向的是那个调用它的对象</p>
</li>
<li>
<p>《javascript语言精髓》中大概概括了4种调用方式：</p>
</li>
<li>
<p>方法调用模式</p>
</li>
<li>
<p>函数调用模式</p>
</li>
<li>
<p>构造器调用模式</p>
</li>
<li>
<p><code>apply / call</code> 调用模式</p>
</li>
</ul>
<h1 id="14-事件模型">14. 事件模型</h1>
<blockquote>
<p><code>W3C</code> 中定义事件的发生经历三个阶段：捕获阶段（<code>capturing</code>）、目标阶段（<code>targetin</code>）、冒泡阶段（<code>bubbling</code>）</p>
</blockquote>
<ul>
<li>冒泡型事件：当你使用事件冒泡时，子级元素先触发，父级元素后触发</li>
<li>捕获型事件：当你使用事件捕获时，父级元素先触发，子级元素后触发</li>
<li>DOM事件流：同时支持两种事件模型：捕获型事件和冒泡型事件</li>
<li>阻止冒泡：在 <code>W3C</code>中，使用 <code>stopPropagetion()</code> 方法；在IE下设置 <code>cancelBubble = true</code></li>
<li>阻止捕获：阻止事件的默认行为，例如 <code>click - &lt;a&gt;</code> 后的跳转。在 <code>W3C</code> 中使用 <code>preventDefault()</code> 方法，在IE下设置<code>window.event.retunValue = false</code></li>
</ul>
<h1 id="15-new操作符具体干了什么">15. new操作符具体干了什么</h1>
<ul>
<li>创建一个空对象，并且 <code>this</code> 变量引用该对象，同时还继承了该函数的原型</li>
<li>属性和方法被加入到 <code>this</code> 引用的对象中</li>
<li>新创建的对象由 <code>this</code> 所引用，并且最后隐式的返回 <code>this</code></li>
</ul>
<h1 id="16-ajax原理">16. Ajax原理</h1>
<ul>
<li><code>Ajax</code> 的原理简单来说是在用户和服务器之间加了一个中间层（<code>AJAX</code>引擎），通过 <code>XmlHttpRequest</code> 对象来向服务器发异步请求，从服务器获得数据，然后用 <code>JavaScript</code> 来操作 <code>DOM</code> 而更新页面。使用户操作与服务器响应异步化。这其中最关键的一步就是从服务器获得请求数据</li>
<li><code>Ajax</code> 的过程只涉及 <code>JavaScript</code> 、<code>XmlHttpRequest</code> 和 <code>DOM</code> 。<code>XmlHttpRequest</code> 是 <code>Ajax</code> 的核心</li>
</ul>
<pre><code class="language-js">// 创建连接
const xhr = new XMLHttpRequest()
// 连接服务器
xhr.open('get',url,true)
// 发送请求
xhr.send(null)
// 接收响应
xhr.onreadystatechange = function(){
    if(xhr.readyState == 4){
        if(xhr.status == 200){
            // 成功操作
        }
        else{
            // 失败操作
        }
    }
}
</code></pre>
<p><strong>Ajax有哪些优缺点</strong></p>
<ul>
<li>优点：
<ul>
<li>通过异步模式，提升了用户体验</li>
<li>优化了浏览器和服务器之间的传输，减少了不必要的数据往返，减少了带宽占用</li>
<li><code>Ajax</code> 在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载</li>
<li><code>Ajax</code> 可以实现动态不刷新 （局部刷新）</li>
</ul>
</li>
<li>缺点：
<ul>
<li>安全问题 <code>Ajax</code> 暴露了与服务器交互的细节</li>
<li>对搜索引擎的支持比较弱</li>
<li>不容易调试</li>
</ul>
</li>
</ul>
<h1 id="17-异步加载js的方式有哪些">17. 异步加载JS的方式有哪些</h1>
<ul>
<li>设置 <code>&lt;script&gt;</code> 属性 <code>async=&quot;async&quot;</code> （一旦脚本可用，则会异步执行）</li>
<li>动态创建 <code>script DOM</code> : <code>document.createElement('script')</code></li>
<li><code>XmlHttpRequest</code> 脚本注入</li>
<li>异步加载库 <code>LABjs</code></li>
<li>模块加载器 <code>Sea.js</code></li>
</ul>
<h1 id="18-哪些操作会造成内存泄漏">18. 哪些操作会造成内存泄漏</h1>
<blockquote>
<p>JavaScript 内存泄漏指对象在不需要使用它时仍然存在，导致占用的内存不能使用或回收</p>
</blockquote>
<ul>
<li>未使用 <code>var</code> 声明的全局变量</li>
<li>循环引用（两个对象相互引用）</li>
<li>控制台日志（console.log）</li>
<li>移除存在绑定事件的 DOM 元素（IE）</li>
<li><code>setTimeout</code> 的第一个参数使用字符串而非函数的话，会引发内存泄漏</li>
<li><strong>垃圾回收</strong>：
<ul>
<li>垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为0（没有其他对象引用过该对象），或对象的唯一引用是循环，那么该对象的内存即可回收</li>
</ul>
</li>
</ul>
<h1 id="19-xml和json的区别">19. XML和JSON的区别</h1>
<ul>
<li>数据体积方面
<ul>
<li><code>JSON</code> 相对于 <code>XML</code> 来讲，数据的体积小，传递的速度更快</li>
</ul>
</li>
<li>数据交互方面
<ul>
<li><code>JSON</code> 与 <code>JavaScript</code> 的交互更加方便，更容易解析处理，更好的数据交互</li>
</ul>
</li>
<li>数据描述方面
<ul>
<li><code>JSON</code> 对数据的描述性比 <code>XML</code> 较差</li>
</ul>
</li>
<li>传输速度方面
<ul>
<li><code>JSON</code> 的速度要远远快于 <code>XML</code></li>
</ul>
</li>
</ul>
<h1 id="20-amd和commonjs的理解">20. AMD和Commonjs的理解</h1>
<ul>
<li><code>Commonjs</code> 是服务器端模块的规范，<code>node.js</code> 采用了这个规范。<code>Commonjs</code>规范加载模块是同步的，也就是说，只有加载完成，才会执行后边的操作。<code>AMD</code> 规范则是非同步加载模块，允许指定回调函数</li>
<li><code>AMD</code> 推荐的风格通过返回一个对象作为模块对象，<code>Commonjs</code> 的风格通过对 <code>module.exports</code> 或 <code>exports</code> 的属性赋值来达到暴露模块对象的目的</li>
</ul>
<p><strong>react中模块引入——import</strong></p>
<p>提出的规范不同<br>
<code>import</code> 是ES6语法,<code>reuqire</code> 是 <code>CommonJs</code> 提出的.</p>
<p><code>import</code> 会通过 <code>babel</code> 转换成 <code>CommonJS</code> 规范。<br>
下面两行代码是等价的</p>
<pre><code class="language-jsx">import component from './component'
// =&gt;
const component = require('./component')
</code></pre>
<h1 id="21-offsetwidthoffsetheightclientwidthclientheight与scrollwidthscrollheight的区别">21. offsetWidth/offsetHeight,clientWidth/clientHeight与scrollWidth/scrollHeight的区别</h1>
<ul>
<li><code>offsetWidth/offsetHeight</code>返回值包含<strong>content + padding + border</strong>，效果与e.getBoundingClientRect()相同
<ul>
<li><code>offsetLeft</code>/ <code>offsetTop</code> (可控制元素移动)</li>
</ul>
</li>
<li><code>clientWidth/clientHeight</code>返回值只包含<strong>content + padding</strong>，如果有滚动条，也<strong>不包含滚动条</strong>
<ul>
<li>可视区指的是浏览器减去上面菜单栏，下面状态栏和任务栏，右边滚动条（如果有的话）后的中间网页内容的单页面积大小。</li>
</ul>
</li>
<li><code>scrollWidth/scrollHeight</code>返回值包含<strong>content + padding + 溢出内容的尺寸</strong></li>
</ul>
<h1 id="22-js中有哪些方法定义对象">22. JS中有哪些方法定义对象</h1>
<ul>
<li>对象字面量：<code>let obj = {}</code></li>
<li>构造函数：<code>let obj = new Object()</code></li>
<li>Object.create() ：<code>let obj = Object.create(Object.prototype)</code></li>
</ul>
<h1 id="23-说说你对promise的了解">23. 说说你对promise的了解</h1>
<ul>
<li>依照 <code>Promise/A+</code> 的定义，<code>Promise</code> 有四种状态：
<ul>
<li><code>pending:</code> 初始状态, 非 <code>fulfilled</code> 或 <code>rejected.</code></li>
<li><code>fulfilled:</code> 成功的操作.</li>
<li><code>rejected:</code> 失败的操作.</li>
<li><code>settled: Promise</code>已被<code>fulfilled</code>或<code>rejected</code>，且不是<code>pending</code></li>
</ul>
</li>
<li>另外， <code>fulfilled</code>与 <code>rejected</code>一起合称 <code>settled</code></li>
<li><code>Promise</code> 对象用来进行延迟(<code>deferred</code>) 和异步(<code>asynchronous</code>) 计算</li>
</ul>
<p><strong>Promise 的构造函数</strong></p>
<ul>
<li>构造一个 <code>Promise</code>，最基本的用法如下：</li>
</ul>
<pre><code class="language-js">let promise = new Promise(function(resolve, reject) {

        if (...) {  // succeed

            resolve(result);

        } else {   // fails

            reject(Error(errMessage));

        }
    });
</code></pre>
<ul>
<li><code>Promise</code> 实例拥有 <code>then</code> 方法（具有 <code>then</code> 方法的对象，通常被称为<code>thenable</code>）。它的使用方法如下：</li>
</ul>
<pre><code class="language-js">promise.then(onFulfilled, onRejected)
</code></pre>
<ul>
<li>接收两个函数作为参数，一个在 <code>fulfilled</code> 的时候被调用，一个在<code>rejected</code>的时候被调用，接收参数就是 <code>future</code>，<code>onFulfilled</code> 对应<code>resolve</code>, <code>onRejected</code>对应 <code>reject</code></li>
</ul>
<h1 id="24-js有哪些内置对象">24. js有哪些内置对象</h1>
<ul>
<li><code>Object</code> 是 <code>JavaScript</code> 中所有对象的父对象</li>
<li>数据封装类对象：<code>Object</code> 、<code>Array</code>、<code>Boolean</code>、<code>Number</code>  和 <code>String</code></li>
<li>其他对象：<code>Function</code> 、<code>Arguments</code>、<code>Math</code>、<code>Date</code>、<code>RegExp</code>、<code>Error</code></li>
</ul>
<h1 id="25-说几条js的基本规范">25. 说几条JS的基本规范</h1>
<ul>
<li>不要在同一行声明多个变量</li>
<li>请使用 <code>===/!==</code> 来比较 <code>true/false</code> 或者数值</li>
<li>使用对象自变量替代 <code>new Array</code> 这种形式</li>
<li>不要使用全局函数</li>
<li><code>Switch</code> 语句必须带有 <code>default</code> 分支</li>
<li><code>If</code> 语句必须使用大括号</li>
<li><code>for-in</code> 循环中的变量应该使用 <code>var</code> 关键字明确限定作用域，从而避免作用域污染</li>
</ul>
<h1 id="26-javascript创建对象的几种方式">26. javascript创建对象的几种方式</h1>
<blockquote>
<p><code>JavaScript</code> 创建对象简单的说，无非就是使用内置对象或各种自定义对象，当然还可以用 <code>JSON</code> 。</p>
</blockquote>
<ul>
<li>对象字面量</li>
</ul>
<pre><code class="language-js">person={firstname:&quot;Mark&quot;,lastname:&quot;Yun&quot;,age:25,eyecolor:&quot;black&quot;};
</code></pre>
<ul>
<li>用 <code>function</code> 来模拟无参的构造函数</li>
</ul>
<pre><code class="language-js">function Person(){}
var person=new Person();//定义一个function，如果使用new&quot;实例化&quot;,该function可以看作是一个Class
person.name=&quot;Mark&quot;;
person.age=&quot;25&quot;;
person.work=function(){
   alert(person.name+&quot; hello...&quot;);
}
person.work();
</code></pre>
<ul>
<li>用 <code>function</code> 来模拟有参构造函数来实现（用 <code>this</code> 关键字定义构造的上下文属性）</li>
</ul>
<pre><code class="language-js">function Pet(name,age,hobby){
       this.name=name;//this作用域：当前对象
       this.age=age;
       this.hobby=hobby;
       this.eat=function(){
           alert(&quot;我叫&quot;+this.name+&quot;,我喜欢&quot;+this.hobby+&quot;,是个程序员&quot;);
       }
}
var maidou =new Pet(&quot;麦兜&quot;,25,&quot;coding&quot;);//实例化、创建对象
maidou.eat();//调用eat方法
</code></pre>
<ul>
<li>用工厂方式来创建（内置对象）</li>
</ul>
<pre><code class="language-js">var wcDog =new Object();
wcDog.name=&quot;旺财&quot;;
wcDog.age=3;
wcDog.work=function(){
   alert(&quot;我是&quot;+wcDog.name+&quot;,汪汪汪......&quot;);
}
wcDog.work();
</code></pre>
<ul>
<li>用原型方式来创建</li>
</ul>
<pre><code class="language-js">function Dog(){}
Dog.prototype.name=&quot;旺财&quot;;
Dog.prototype.eat=function(){
	alert(this.name+&quot;是个吃货&quot;);
}
var wangcai =new Dog();
wangcai.eat();
</code></pre>
<ul>
<li>用混合方式来创建</li>
</ul>
<pre><code class="language-js"> function Car(name,price){
	this.name=name;
	this.price=price;
}
Car.prototype.sell=function(){
	alert(&quot;我是&quot;+this.name+&quot;，我现在卖&quot;+this.price+&quot;万元&quot;);
}
var camry =new Car(&quot;凯美瑞&quot;,27);
camry.sell();
</code></pre>
<h1 id="27-eval是做什么的">27. eval是做什么的</h1>
<ul>
<li>它的功能是把对应的字符串解析成 <code>js</code> 代码并运行</li>
<li>应该避免使用 <code>eval</code> ,不安全，非常耗费性能（2次，一次解析成 <code>js</code> 语句，一次执行）</li>
<li>由 <code>JSON</code> 字符串转换为 <code>JSON</code> 对象的时候可以用 <code>eval</code>  ，<code>let obj = eval('('+str+')')</code></li>
</ul>
<h1 id="28-nullundefined-的区别">28. null,undefined 的区别</h1>
<ul>
<li><code>undefined</code> 表示不存在这个值</li>
<li><code>undefined</code> 是一个表示“无”的原始值或者说表示“缺少值”，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 <code>undefined</code></li>
<li>例如变量被声明了，但没有赋值时，就等于 <code>undefined</code></li>
<li><code>null</code> 表示一个对象被定义了，值为“空值”</li>
<li><code>null</code> 是一个对象（空对象，没有任何属性和方法）</li>
<li>例如作为函数的参数，表示该函数的参数不是对象</li>
<li>在验证 <code>null</code> 时，一定要用 <code>===</code> ，因为 <code>==</code> 无法分别 <code>null</code> 和 <code>undefined</code></li>
</ul>
<h1 id="29-1-2-3mapparseint-答案是多少">29. [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(parseInt) 答案是多少</h1>
<ul>
<li><code>[1,NaN,NaN]</code> 因为 <code>parseInt</code> 需要两个参数 <code>(val,radix)</code> ，其中 <code>radix</code> 表示解析时用的参数</li>
<li><code>map</code> 穿了 3 个 <code>(element,index,array)</code>,对应的 <code>raidx</code> 不合法导致解析失败返回 <code>NaN</code></li>
<li>失败原因：
<ul>
<li>当传入 <code>(&quot;2&quot;,1)</code> 时，因为 <code>parseInt</code> 要求 <code>radix</code> 范围为 2~36 ，所有传入的 <code>radix</code> 不合法返回 <code>NaN</code></li>
<li>当传入 <code>(&quot;3&quot;,2)</code> 时，即把 <code>&quot;3&quot;</code> 从二进制转换为十进制，2进制中没有 3 ，所以不合法返回NaN</li>
</ul>
</li>
</ul>
<h1 id="30-javascript-代码中的use-strict是什么意思">30. javascript 代码中的&quot;use strict&quot;;是什么意思</h1>
<ul>
<li><code>use strict</code>是一种<code>ECMAscript 5</code> 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,使<code>JS</code>编码更加规范化的模式,消除<code>Javascript</code>语法的一些不合理、不严谨之处，减少一些怪异行为</li>
</ul>
<h1 id="31-json的了解">31. JSON的了解</h1>
<ul>
<li><code>JSON(JavaScript Object Notation)</code> 是一种轻量级的数据交换格式</li>
<li>它是基于<code>JavaScript</code>的一个子集。数据格式简单, 易于读写, 占用带宽小</li>
<li><code>JSON</code>字符串转换为JSON对象:</li>
</ul>
<pre><code class="language-javascript">var obj = eval('('+ str +')');
var obj = str.parseJSON();
var obj = JSON.parse(str);
</code></pre>
<ul>
<li><code>JSON</code>对象转换为JSON字符串：</li>
</ul>
<pre><code class="language-js">var last = obj.toJSONString();
var last = JSON.stringify(obj);
</code></pre>
<h1 id="32-js延迟加载的方式有哪些">32. js延迟加载的方式有哪些</h1>
<ul>
<li>
<p>设置 <code>&lt;script&gt;</code> 属性 <code>defer=&quot;defer&quot;</code> （脚本将在页面完成解析时执行）</p>
</li>
<li>
<p>动态创建 <code>script DOM</code>：<code>document.createElement('script');</code></p>
</li>
<li>
<p><code>XmlHttpRequest</code> 脚本注入</p>
</li>
<li>
<p>延迟加载工具 <code>LazyLoad</code></p>
</li>
</ul>
<h1 id="33-defer和async">33. defer和async</h1>
<ul>
<li><code>defer</code>并行加载<code>js</code>文件，会按照页面上<code>script</code>标签的顺序执行</li>
<li><code>async</code>并行加载<code>js</code>文件，下载完成立即执行，不会按照页面上<code>script</code>标签的顺序执行</li>
</ul>
<h1 id="34-同步和异步的区别">34. 同步和异步的区别</h1>
<ul>
<li>同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作</li>
<li>异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容</li>
</ul>
<h1 id="35-说说严格模式的限制">35. 说说严格模式的限制</h1>
<ul>
<li>变量必须声明后再使用</li>
<li>函数的参数不能有同名属性，否则报错</li>
<li>不能使用 <code>with</code> 语句</li>
<li>不能对只读属性赋值，否则报错</li>
<li>不能使用前缀0表示八进制数，否则报错</li>
<li>不能删除不可删除的属性，否则报错</li>
<li>不能删除变量<code>delete prop</code>，会报错，只能删除属性<code>delete global[prop]</code></li>
<li><code>eval</code>不会在它的外层作用域引入变量</li>
<li><code>eval</code>和<code>arguments</code>不能被重新赋值</li>
<li><code>arguments</code>不会自动反映函数参数的变化</li>
<li>不能使用<code>arguments.callee</code></li>
<li>不能使用<code>arguments.caller</code></li>
<li>禁止<code>this</code>指向全局对象</li>
<li>不能使用<code>fn.caller</code>和<code>fn.arguments</code>获取函数调用的堆栈</li>
<li>增加了保留字（比如<code>protected</code>、<code>static</code>和<code>interface</code>）</li>
</ul>
<h1 id="36-attribute和property的区别是什么">36. attribute和property的区别是什么</h1>
<ul>
<li><code>attribute</code>是<code>dom</code>元素在文档中作为<code>html</code>标签拥有的属性；</li>
<li><code>property</code>就是<code>dom</code>元素在<code>js</code>中作为对象拥有的属性。</li>
<li>对于<code>html</code>的标准属性来说，<code>attribute</code>和<code>property</code>是同步的，是会自动更新的</li>
<li>但是对于自定义的属性来说，他们是不同步的</li>
</ul>
<h1 id="37-谈谈你对es6的理解">37. 谈谈你对ES6的理解</h1>
<ul>
<li>新增模板字符串（为 <code>JavaScript</code> 提供了简单的字符串插值功能）</li>
<li>箭头函数</li>
<li><code>for-of</code> （用来遍历数据—例如数组中的值）</li>
<li><code>arguments</code> 对象可被不定参数和默认参数完美替代</li>
<li><code>ES6</code> 将 <code>Promise</code> 对象纳入规范，提供了原生的 <code>Promise</code> 对象</li>
<li>增加了 <code>let</code> 和 <code>const</code> 命令，用来声明变量</li>
<li>增加了块级作用域</li>
<li><code>let</code> 命令实际上增加了块级作用域</li>
<li>引入 <code>module</code> 模块概念</li>
</ul>
<h1 id="38-面向对象编程及面向过程编程">38. 面向对象编程及面向过程编程</h1>
<ul>
<li>面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了</li>
<li>面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为</li>
<li>面向对象是以功能来划分问题，而不是步骤</li>
</ul>
<p><strong>面向对象编程思想</strong></p>
<ul>
<li>基本思想是使用对象，类，继承，封装等基本概念来进行程序设计</li>
<li>优点
<ul>
<li>易维护
<ul>
<li>采用面向对象思想设计的结构，可读性高，由于继承的存在，即使改变需求，那么维护也只是在局部模块，所以维护起来非常方便和较低成本的</li>
</ul>
</li>
<li>易扩展</li>
<li>开发工作的重要性、继承性高，降低重复工作量</li>
<li>缩短了开发周期</li>
</ul>
</li>
</ul>
<h1 id="39-对web标准-可用性-可访问性的理解">39. 对web标准、可用性、可访问性的理解</h1>
<ul>
<li>可用性(Usability)：产品是否 容易上手，用户能否完成任务，效率如何，以及这过程中用户的主观感受可好，是从用户的角度来看产品的质量。可用性好意味着产品质量高，是企业的核心竞争力</li>
<li>可访问性(Accessibility)：Web内容对于残障用户的可阅读和可理解性</li>
<li>可维护性(Maintainability)：一般包含两个层次，一是当系统出现问题时，快速定位并解决问题的成本，成本低则可维护性好。二是代码是否容易被人理解，是否容易修改和增强功能</li>
</ul>
<h1 id="40-如何通过js判断一个数组">40. 如何通过JS判断一个数组</h1>
<ul>
<li><code>instanceof</code> 方法
<ul>
<li><code>instanceof</code> 运算符是用来测试一个对象是否在其原型链原型构造函数的属性</li>
</ul>
</li>
</ul>
<pre><code class="language-js">let arr = []
arr instanceof Array  // true
</code></pre>
<ul>
<li><code>constructor</code> 方法
<ul>
<li><code>constructor</code> 属性返回对创建此对象的数组函数的引用，就是返回对象相对应的构造函数</li>
</ul>
</li>
</ul>
<pre><code class="language-js">let arr = []
arr.constructor == Array  // true
</code></pre>
<ul>
<li><code>ES5</code> 新增方法 <code>isArray()</code></li>
</ul>
<pre><code class="language-js">let a = new Array(123)
Array.isArray(a)    // true
</code></pre>
<ul>
<li>最简单的方法
<ul>
<li>这种写法，是 <code>Jquery</code> 正在使用的</li>
</ul>
</li>
</ul>
<pre><code class="language-js">Object.prototype.toString.call([]) == '[Object Array]'

// 利用这个方法，可以写一个返回数据类型的方法
let isType = function(obj){
    return Object.prototype.toString.call(obj).slice(8,-1)
}
</code></pre>
<h1 id="41-let和var的区别">41. let和var的区别</h1>
<ul>
<li><code>let</code> 命令不存在变量提升，如果在 <code>let</code> 前使用，会导致报错</li>
<li>如果块区中存在 <code>let</code> 和 <code>const</code> 命令，就会形成闭合作用域</li>
<li><code>let</code> 不允许重复声明，因此，不能在函数内部重新声明参数</li>
</ul>
<h1 id="42-cookie和session的区别及session的生命周期">42. cookie和session的区别及session的生命周期</h1>
<p><strong>区别</strong></p>
<ul>
<li><code>cookie</code> 数据存放在客户端，<code>session</code> 数据存放在服务器上</li>
<li><code>cookie</code> 不是很安全，别人可以分析存放在本地的 <code>cookie</code> 并进行 <code>cookie</code> 欺骗，考虑到安全应当使用 <code>session</code></li>
<li><code>session</code> 会在一定时间内保存在服务器上。当访问增多，会比较占用服务器的性能，考虑到减轻服务器性能方面，应当使用 <code>cookie</code></li>
<li>单个 <code>cookie</code> 保存的数据长度不能超过4K，很多浏览器都限制一个网址最多保存20个 <code>cookie</code></li>
</ul>
<p><strong>session生命周期</strong></p>
<ul>
<li><code>session</code> 保存在服务器端，为了获取更高的存取速度，服务器一般会把 <code>session</code> 放在内存里边，每个用户都会有一个独立的 <code>session</code></li>
<li>如果 <code>session</code> 里面的内容太过复杂，当大量的用户访问服务器时，可能会导致内存溢出，所以我们的 <code>session</code> 内容应当适当的精简</li>
<li>但我们第一次访问服务器时，服务器会给我们自动创建一个 <code>session</code> ，生成 <code>session</code> 后，只要用户继续访问，服务器就会更新 <code>session</code> 的最后访问时间，并且维护这个 <code>session</code></li>
<li>当用户访问服务器一次，无论是否读完了 <code>session</code> ，服务器都会认定这个<code>session</code> 活跃了一次，当越来越多的用户访问服务器时，<code>session</code> 会越来越多。</li>
<li>为了防止内存溢出，服务器会把长时间没有活跃的 <code>session</code> 删除。这个时间就是 <code>session</code> 的超时时间，过了超时时间，我们的<code>session</code> 就会自动失效</li>
</ul>
<h1 id="43-map与foreach的区别">43. map与forEach的区别</h1>
<ul>
<li><code>forEach</code> 方法，是最基本的方法，就是遍历和循环，默认有三个传参：分别是遍历的数组内容 <code>item</code> 、数组索引 <code>index</code> 、和当前遍历数组 <code>Array</code></li>
<li><code>map</code> 方法，基本用法与 <code>forEach</code> 一致，但是不同的，它会返回一个新的数组，所以在callback需要有 <code>return</code> 值，如果没有。会返回 <code>undefined</code></li>
</ul>
<h1 id="44-谈一谈对函数式编程的理解">44. 谈一谈对函数式编程的理解</h1>
<ul>
<li>简单说，“函数式编程”是一种“编程范式”，也就是如何编写程序的方法论</li>
<li>它具有以下特性：闭包和高阶函数、惰性计算、递归、函数是“第一等公民”、只用“表达式”</li>
<li>函数式编程更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而非设计一个复杂的执行过程</li>
<li>简单来讲，就是要把过程逻辑写成函数，定义好输入参数，只关心它的输出结果。即是一种描述集合和集合之间的转换关系，输入通过函数都会返回有且只有一个输出值</li>
</ul>
<h1 id="45-箭头函数与普通函数的区别">45. 箭头函数与普通函数的区别</h1>
<ul>
<li>语法更加简洁、清晰</li>
<li>箭头函数不会创建自己的 <code>this</code></li>
</ul>
<blockquote>
<p>箭头函数不会创建自己的this,所以它没有自己的this，它只会从自己的作用域链的上一层继承this。</p>
</blockquote>
<blockquote>
<p>箭头函数没有自己的<code>this</code>，它会捕获自己在<strong>定义时</strong>（注意，是定义时，不是调用时）所处的<strong>外层执行环境的<code>this</code></strong>，并继承这个<code>this</code>值。所以，箭头函数中<code>this</code>的指向在它被定义的时候就已经确定了，之后永远不会改变。</p>
</blockquote>
<ul>
<li>
<p>箭头函数继承而来的 <code>this</code> 指向永远不变</p>
</li>
<li>
<p><code>call / apply / bind</code> 无法改变箭头函数中 <code>this</code> 的指向</p>
</li>
<li>
<p>箭头函数不能作为构造函数使用</p>
</li>
<li>
<p>箭头函数没有自己的 <code>arguments</code> ，可以在箭头函数中使用 <code>rest (...变量名)</code> 参数代替</p>
</li>
<li>
<p>箭头函数没有原型 <code>prototype</code></p>
</li>
<li>
<p>箭头函数不用作 <code>Generator</code> 函数，不能使用 <code>yelid</code> 关键字</p>
<ul>
<li>因为标准规范定义了生成器必须是 <code>function*</code> 。箭头函数就无法匹配这个token</li>
</ul>
</li>
</ul>
<h1 id="46-异步编程的实现方式">46. 异步编程的实现方式</h1>
<ul>
<li>回调函数
<ul>
<li>优点：简单，容易理解</li>
<li>缺点：不利于维护，代码耦合高</li>
</ul>
</li>
<li>事件监听（采用时间驱动模式，取决于某个事件是否发生）
<ul>
<li>优点：容易理解，可以绑定多个事件，每个事件可以指定多个回调函数</li>
<li>缺点：事件驱动型，流程不够清晰</li>
</ul>
</li>
<li>发布/订阅(观察者模式)
<ul>
<li>类似于事件监听，但是可以通过‘消息中心’，了解现在有多少发布者，多少订阅者</li>
</ul>
</li>
<li><code>Promise</code> 对象
<ul>
<li>优点：可以利用 <code>then</code> 方法，进行链式写法；可以书写错误时的回调函数；</li>
<li>缺点：编写和理解，相对比较难</li>
</ul>
</li>
<li><code>Generator</code> 函数
<ul>
<li>在函数的执行过程中,将函数的执行权转义出去,在函数外部还可以将执行权给转移回来。</li>
<li>优点：函数体内外的数据交换、错误处理机制</li>
<li>缺点：流程管理不方便</li>
</ul>
</li>
<li><code>async</code> 函数
<ul>
<li><code>async</code> 函数是 <code>generator</code> 和 <code>promise</code> 实现的一个自动执行的语法糖,它内部自带执行器,当函数内部执行到一个 <code>await</code> 语句的时候,如果语句返回一个 <code>promise</code> 对象,那么函数将会等待 <code>promise</code> 对象的状态变为 <code>resolve</code> 后再继续向下执行</li>
<li>优点：内置执行器、更好的语义、更广的适用性、返回的是 <code>Promise</code>、结构清晰。</li>
<li>缺点：错误处理机制</li>
</ul>
</li>
</ul>
<h1 id="47-js动画与css动画区别及相应实现">47. JS动画与CSS动画区别及相应实现</h1>
<ul>
<li><code>CSS3</code>的动画的优点
<ul>
<li>在性能上会稍微好一些，浏览器会对<code>CSS3</code>的动画做一些优化</li>
<li>代码相对简单</li>
</ul>
</li>
<li>缺点
<ul>
<li>在动画控制上不够灵活</li>
<li>兼容性不好</li>
</ul>
</li>
<li><code>JavaScript</code>的动画正好弥补了这两个缺点，控制能力很强，可以单帧的控制、变换，同时写得好完全可以兼容<code>IE6</code>，并且功能强大。对于一些复杂控制的动画，使用<code>javascript</code>会比较靠谱。而在实现一些小的交互动效的时候，就多考虑考虑<code>CSS</code>吧</li>
</ul>
<h1 id="48-js-数组和对象的遍历方式以及几种方式的比较">48. JS 数组和对象的遍历方式，以及几种方式的比较</h1>
<blockquote>
<p>通常我们会用循环的方式来遍历数组。但是循环是 导致js 性能问题的原因之一。一般我们会采用下几种方式来进行数组的遍历</p>
</blockquote>
<ul>
<li><code>for in</code>循环</li>
<li><code>for</code> 循环</li>
<li><code>forEach</code>
<ul>
<li>这里的 <code>forEach</code>回调中两个参数分别为 <code>value</code>，<code>index</code></li>
<li><code>forEach</code> 无法遍历对象</li>
<li>IE不支持该方法；<code>Firefox</code> 和 <code>chrome</code> 支持</li>
<li><code>forEach</code> 无法使用 <code>break</code>，<code>continue</code> 跳出循环，且使用 <code>return</code> 是跳过本次循环</li>
</ul>
</li>
<li>这两种方法应该非常常见且使用很频繁。但实际上，这两种方法都存在性能问题</li>
<li>在方式一中，<code>for-in</code>需要分析出<code>array</code>的每个属性，这个操作性能开销很大。用在 <code>key</code> 已知的数组上是非常不划算的。所以尽量不要用<code>for-in</code>，除非你不清楚要处理哪些属性，例如 <code>JSON</code>对象这样的情况</li>
<li>在方式2中，循环每进行一次，就要检查一下数组长度。读取属性（数组长度）要比读局部变量慢，尤其是当 <code>array</code> 里存放的都是 <code>DOM</code> 元素，因为每次读取都会扫描一遍页面上的选择器相关元素，速度会大大降低</li>
</ul>
<h1 id="49-事件的各个阶段">49. 事件的各个阶段</h1>
<ul>
<li>1：捕获阶段 ---&gt; 2：目标阶段 ---&gt; 3：冒泡阶段</li>
<li><code>document</code>  ---&gt;  <code>target</code> 目标  ---&gt;  <code>document</code></li>
<li>由此，<code>addEventListener</code> 的第三个参数设置为 <code>true</code> 和 <code>false</code> 的区别已经非常清晰了
<ul>
<li><code>true</code> 表示该元素在事件的 “捕获阶段” (由外向内传递时) 响应事件</li>
<li><code>false</code> 表示该元素在事件的 “冒泡阶段” (由内向外传递时) 响应事件</li>
</ul>
</li>
</ul>
<h1 id="50-let-var-const">50. let var const</h1>
<p><strong>let</strong></p>
<ul>
<li>允许声明一个作用域被限制在块级中的变量、语句或者表达式</li>
<li><code>let</code> 绑定不受变量提升的约束，这意味着 <code>let</code> 声明不会被提升到当前</li>
<li>该变量处于从块开始到初始化处理的“暂存死区”</li>
</ul>
<p><strong>var</strong></p>
<ul>
<li>声明变量的作用域限制在其声明位置的上下文中，而非声明变量总是全局的</li>
<li>由于变量声明（以及其他声明）总是在任意代码执行之前处理的，所以在代码中的任意位置声明变量总是等效于在代码开头声明</li>
</ul>
<p><strong>const</strong></p>
<ul>
<li>声明创建一个值的只读引用 (即指针)</li>
<li>基本数据当值发生改变时，那么其对应的指针也将发生改变，故造成 <code>const</code>声明基本数据类型时，再将其值改变时，将会造成报错</li>
<li>但是如果是复合类型时，如果只改变复合类型的其中某个<code>Value</code>项时， 将还是正常使用</li>
</ul>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://font-ds.github.io/tag/1D40I4gWP/" class="tag">
                    JavaScript
                  </a>
                
              </div>
            
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>


  <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad()
  </script>





  </body>
</html>
